{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Jenkins Containers Project Site This project site serves as a gathering point for resources to build Docker containers that run Jenkins . Reading Notes The terms container | image might be used interchangeably, it will be of best effort to keep consistent with the notion that containers are instances of an image. Hence terminology should be appropriate where needed. Currently the only images being built are Docker images, so any notion of a Jenkins Image | image is to be assumed as a Docker container/image. Types of Jenkins Images Base Image Will contain Jenkins configurations that all children will use, e.g. shell that the jobs will run in user account(s) global credentials GitHub Child Image The differentiation of children images will be based on the job(s) that Jenkins runs. Based currently on jobs.toml (see Image Git Repo Layout ) Image Git Repos jenkins-docker-base This is the base image Git repo in which other Jenkins images will be built on top of. jenkins-docker-torkel Other Git Repos jcascutil Used to aid in constructing configuration as code (CasC) files for Jenkins . jenkins-infrastructure Used in miscellaneous tasks when managing a Jenkins environment. Image Docker Repos jenkins-base A base container, built from the respective Image Git Repo . jenkins-torkel A child container, contains following jobs: jenkins-packerbuilds","title":"Home"},{"location":"index.html#jenkins-containers-project-site","text":"This project site serves as a gathering point for resources to build Docker containers that run Jenkins .","title":"Jenkins Containers Project Site"},{"location":"index.html#reading-notes","text":"The terms container | image might be used interchangeably, it will be of best effort to keep consistent with the notion that containers are instances of an image. Hence terminology should be appropriate where needed. Currently the only images being built are Docker images, so any notion of a Jenkins Image | image is to be assumed as a Docker container/image.","title":"Reading Notes"},{"location":"index.html#types-of-jenkins-images","text":"Base Image Will contain Jenkins configurations that all children will use, e.g. shell that the jobs will run in user account(s) global credentials GitHub Child Image The differentiation of children images will be based on the job(s) that Jenkins runs. Based currently on jobs.toml (see Image Git Repo Layout )","title":"Types of Jenkins Images"},{"location":"index.html#image-git-repos","text":"jenkins-docker-base This is the base image Git repo in which other Jenkins images will be built on top of. jenkins-docker-torkel","title":"Image Git Repos"},{"location":"index.html#other-git-repos","text":"jcascutil Used to aid in constructing configuration as code (CasC) files for Jenkins . jenkins-infrastructure Used in miscellaneous tasks when managing a Jenkins environment.","title":"Other Git Repos"},{"location":"index.html#image-docker-repos","text":"jenkins-base A base container, built from the respective Image Git Repo . jenkins-torkel A child container, contains following jobs: jenkins-packerbuilds","title":"Image Docker Repos"},{"location":"layouts.html","text":"Image Git Repo Layout This is expected to change overtime. So don\u2019t rely on this indefinitely. This should be what is expected in a Image Git Repo , you may or may not find additional files in other image repos. Will denote optional files. Base Image: .gitignore casc.yaml (optional) Can use a different filename. Must have \u2018 casc \u2019 somewhere in its filename and ' yaml' or ' yml**' as the filename extension. Assuming you wish to use the Dockerfile as is. Also assuming you are using the jcascutil program as is. Dockerfile plugins.txt Child Image: .gitignore child-casc.yaml (optional) Can use a different filename. No restrictions here. This is used to be merged with the base image\u2019s \u2018 casc.yaml \u2019. docker-compose.yaml (optional) Dockerfile Makefile jobs.toml Used by the jcascutil program. setup","title":"Repo Layouts"},{"location":"layouts.html#image-git-repo-layout","text":"This is expected to change overtime. So don\u2019t rely on this indefinitely. This should be what is expected in a Image Git Repo , you may or may not find additional files in other image repos. Will denote optional files. Base Image: .gitignore casc.yaml (optional) Can use a different filename. Must have \u2018 casc \u2019 somewhere in its filename and ' yaml' or ' yml**' as the filename extension. Assuming you wish to use the Dockerfile as is. Also assuming you are using the jcascutil program as is. Dockerfile plugins.txt Child Image: .gitignore child-casc.yaml (optional) Can use a different filename. No restrictions here. This is used to be merged with the base image\u2019s \u2018 casc.yaml \u2019. docker-compose.yaml (optional) Dockerfile Makefile jobs.toml Used by the jcascutil program. setup","title":"Image Git Repo Layout"},{"location":"philosophy.html","text":"Build Philosophy Future Jenkins Images created should adhere (assuming a Image Git/Docker repo is created like the others) to the following philosophy. The lifecycle of building a Jenkins Image is as followed: Preimage Build The operations needed to gather all the resources for an image build should occur here. What this means for \u2018 Image Builds \u2019: We want to ensure that Dockerfiles are easy to follow, and can be maintained. That said, with all the resources gathered in this step means that Image Builds can easily transfer over contents using the Docker context . What this means for \u2018 Container Runtime \u2019: Like Image Builds , Container Runtime also benefits from having all the resources needed when at runtime. This removes a moderate amount of runtime error from occurring and ensures for a more deterministic runtime. Pulling additional resources from the network or running additional groovy scripts only complicate the runtime. Image Build To reiterate, Dockerfiles should be simple and easy to follow. Simple activities like updating packages, chmoding files, and copying files over from the Docker context are encouraged. However, mangling the image file system is not. Multistage builds are ok, but not for just running one command and gathering its results. Multistage builds should be used judiciously. Container Runtime There should be a narrow scope for what a container should do at runtime. That said, the modularity of a Jenkins Image shines here, as \u2018 casc.yaml \u2019 will heavily utilize environment variables to be evaluated at runtime. This allows the same image to be run differently depending on the need(s). e.g. One way to ensure that environment variables are set at runtime for the Jenkins Image is to use docker-compose. docker-compose injects environment variables into the container runtime based on what you pass in as their values. The JCasC plugin evaluates these environment variables if they exist when looking in the \u2018 casc.yaml \u2019.","title":"Build Philosophy"},{"location":"philosophy.html#build-philosophy","text":"Future Jenkins Images created should adhere (assuming a Image Git/Docker repo is created like the others) to the following philosophy. The lifecycle of building a Jenkins Image is as followed: Preimage Build The operations needed to gather all the resources for an image build should occur here. What this means for \u2018 Image Builds \u2019: We want to ensure that Dockerfiles are easy to follow, and can be maintained. That said, with all the resources gathered in this step means that Image Builds can easily transfer over contents using the Docker context . What this means for \u2018 Container Runtime \u2019: Like Image Builds , Container Runtime also benefits from having all the resources needed when at runtime. This removes a moderate amount of runtime error from occurring and ensures for a more deterministic runtime. Pulling additional resources from the network or running additional groovy scripts only complicate the runtime. Image Build To reiterate, Dockerfiles should be simple and easy to follow. Simple activities like updating packages, chmoding files, and copying files over from the Docker context are encouraged. However, mangling the image file system is not. Multistage builds are ok, but not for just running one command and gathering its results. Multistage builds should be used judiciously. Container Runtime There should be a narrow scope for what a container should do at runtime. That said, the modularity of a Jenkins Image shines here, as \u2018 casc.yaml \u2019 will heavily utilize environment variables to be evaluated at runtime. This allows the same image to be run differently depending on the need(s). e.g. One way to ensure that environment variables are set at runtime for the Jenkins Image is to use docker-compose. docker-compose injects environment variables into the container runtime based on what you pass in as their values. The JCasC plugin evaluates these environment variables if they exist when looking in the \u2018 casc.yaml \u2019.","title":"Build Philosophy"},{"location":"processes.html","text":"Tagging Commits In Image Git Repos Current versioning schema roughly looks like this: \u2018 vx.x.x \u2019, with x being some positive int. Should represent major.minor.patch , that being the intent. When tagging a point in the commit tree, the following process is in place (again, just at a best effort level). This should be followed in descending order, these are known as rules : If the Dockerfile changed as part of a new commit, then the image has changed and the tag should be incremented and assigned to the new commit. If some part of an image file system has changed (e.g. casc.yaml that should be in the $JENKINS_HOME ), then the most recent tag (e.g. if v1.0.0 and v1.0.1 exist, v1.0.1 would be the most recent tag) should be removed from its previous commit and reassigned to the new commit but not incremented. If the Dockerfile has not changed, and no part of an image\u2019s file system has changed, then no tagging needs to occur with the new commit. To follow this rule , if a base image changes, the child image does not need to increment/reassign its tag. EXTRA NOTE : Jenkins Images built for a particular version can be from any commit that follows rule (iii) up to any other commit that follows rule (i) / rule (ii) . Any commits existing between them are assumed to follow rule (iii) and can be used for that particular version. Image file system changes > Dockerfile changes This needs to be brought up because looking at rule (ii) in the above procedure list, moving a particular tag to a new commit when its file system has changed means it will be harder to know when that image changed (aka, the tag incremented) when looking through the commit tree. Rational is that currently Dockerfiles have been skimmed down and the actual image should not change as often as its contents. Building Jenkins Images NOTE: TAGGING COMMITS SHOULD OCCUR FIRST AND BE SORTED OUT! OTHERWISE THERE IS NO GUARANTEE AN IMAGE WILL BE IN LINE WITH ITS IMAGE GIT REPO. To make the process of running a docker build easier, each Image Git Repo should provide a Makefile that will prepare everything to construct a Jenkins Image . This script will more than likely utilize the jcascutil program. This serves two fold: To provide a blueprint/trail for the \u2018 casc.yaml \u2019 used by the Jenkins service in the container. This is so we know how the casc.yaml was created. Though again, this isn\u2019t an image change but a Jenkins config change (meaning the file system will change with the new casc.yaml ). To have fewer keystrokes used...a programmer\u2019s goal ideally.","title":"Processes"},{"location":"processes.html#tagging-commits-in-image-git-repos","text":"Current versioning schema roughly looks like this: \u2018 vx.x.x \u2019, with x being some positive int. Should represent major.minor.patch , that being the intent. When tagging a point in the commit tree, the following process is in place (again, just at a best effort level). This should be followed in descending order, these are known as rules : If the Dockerfile changed as part of a new commit, then the image has changed and the tag should be incremented and assigned to the new commit. If some part of an image file system has changed (e.g. casc.yaml that should be in the $JENKINS_HOME ), then the most recent tag (e.g. if v1.0.0 and v1.0.1 exist, v1.0.1 would be the most recent tag) should be removed from its previous commit and reassigned to the new commit but not incremented. If the Dockerfile has not changed, and no part of an image\u2019s file system has changed, then no tagging needs to occur with the new commit. To follow this rule , if a base image changes, the child image does not need to increment/reassign its tag. EXTRA NOTE : Jenkins Images built for a particular version can be from any commit that follows rule (iii) up to any other commit that follows rule (i) / rule (ii) . Any commits existing between them are assumed to follow rule (iii) and can be used for that particular version. Image file system changes > Dockerfile changes This needs to be brought up because looking at rule (ii) in the above procedure list, moving a particular tag to a new commit when its file system has changed means it will be harder to know when that image changed (aka, the tag incremented) when looking through the commit tree. Rational is that currently Dockerfiles have been skimmed down and the actual image should not change as often as its contents.","title":"Tagging Commits In Image Git Repos"},{"location":"processes.html#building-jenkins-images","text":"NOTE: TAGGING COMMITS SHOULD OCCUR FIRST AND BE SORTED OUT! OTHERWISE THERE IS NO GUARANTEE AN IMAGE WILL BE IN LINE WITH ITS IMAGE GIT REPO. To make the process of running a docker build easier, each Image Git Repo should provide a Makefile that will prepare everything to construct a Jenkins Image . This script will more than likely utilize the jcascutil program. This serves two fold: To provide a blueprint/trail for the \u2018 casc.yaml \u2019 used by the Jenkins service in the container. This is so we know how the casc.yaml was created. Though again, this isn\u2019t an image change but a Jenkins config change (meaning the file system will change with the new casc.yaml ). To have fewer keystrokes used...a programmer\u2019s goal ideally.","title":"Building Jenkins Images"}]}