{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the <Jenkins Containers> Project This project site serves as a gathering point for resources to build Docker containers that run Jenkins . Reading Notes The terms container | image might be used interchangeably, best effort to keep consistent with the notion that containers are instances of an image. Hence terminology should be appropriate where needed. Well a container is just a writable layer on top of an image but that\u2019s more detail than needed here. Currently the only images being built are Docker images, so any notion of a Jenkins Image | image is to be assumed as a Docker container/image. Types of Jenkins Images Base Image Will contain Jenkins configurations that all children will use, e.g. shell that the jobs will run in user account(s) global credentials GitHub Child Image The differentiation of children images will be based on the job(s) that Jenkins runs. Based currently on jobs.toml (see Image Git Repo Layout ) Image Git Repos jenkins-docker-base This is the base image Git repo in which other Jenkins images will be built on top of. jenkins-docker-torkel Other Git Repos jcasc.py Used to aid in building Jenkins images . jenkins-infrastructure Used in miscellaneous tasks when managing a Jenkins environment. Image Docker Repos jenkins-base This is the base image Docker repo in which other Jenkins images will build on top of. jenkins-torkel Child image, contains following jobs: jenkins-packerbuilds","title":"Home"},{"location":"#welcome-to-the-jenkins-containers62-project","text":"This project site serves as a gathering point for resources to build Docker containers that run Jenkins .","title":"Welcome to the &lt;Jenkins Containers> Project"},{"location":"#reading-notes","text":"The terms container | image might be used interchangeably, best effort to keep consistent with the notion that containers are instances of an image. Hence terminology should be appropriate where needed. Well a container is just a writable layer on top of an image but that\u2019s more detail than needed here. Currently the only images being built are Docker images, so any notion of a Jenkins Image | image is to be assumed as a Docker container/image.","title":"Reading Notes"},{"location":"#types-of-jenkins-images","text":"Base Image Will contain Jenkins configurations that all children will use, e.g. shell that the jobs will run in user account(s) global credentials GitHub Child Image The differentiation of children images will be based on the job(s) that Jenkins runs. Based currently on jobs.toml (see Image Git Repo Layout )","title":"Types of Jenkins Images"},{"location":"#image-git-repos","text":"jenkins-docker-base This is the base image Git repo in which other Jenkins images will be built on top of. jenkins-docker-torkel","title":"Image Git Repos"},{"location":"#other-git-repos","text":"jcasc.py Used to aid in building Jenkins images . jenkins-infrastructure Used in miscellaneous tasks when managing a Jenkins environment.","title":"Other Git Repos"},{"location":"#image-docker-repos","text":"jenkins-base This is the base image Docker repo in which other Jenkins images will build on top of. jenkins-torkel Child image, contains following jobs: jenkins-packerbuilds","title":"Image Docker Repos"},{"location":"layouts/","text":"Image Git Repo Layout This is expected to change overtime. So don\u2019t rely on this indefinitely. This also should be what must be in a Image Git Repo , you may or may not find other files tracked by the repos. Will denote optional files. Base Image: .gitignore casc.yaml (optional) Can use a different filename. Must have \u2018 casc \u2019 somewhere in its filename and yaml/yml as the filename extension. Dockerfile plugins.txt Child Image: .gitignore child-casc.yaml (optional) Can use a different filename. No restrictions here. This is used to be merged with the base image\u2019s \u2018 casc.yaml \u2019. docker-compose.yaml (optional) Dockerfile jobs.toml Used by the jcasc.py program. setup","title":"Repo Layouts"},{"location":"layouts/#image-git-repo-layout","text":"This is expected to change overtime. So don\u2019t rely on this indefinitely. This also should be what must be in a Image Git Repo , you may or may not find other files tracked by the repos. Will denote optional files. Base Image: .gitignore casc.yaml (optional) Can use a different filename. Must have \u2018 casc \u2019 somewhere in its filename and yaml/yml as the filename extension. Dockerfile plugins.txt Child Image: .gitignore child-casc.yaml (optional) Can use a different filename. No restrictions here. This is used to be merged with the base image\u2019s \u2018 casc.yaml \u2019. docker-compose.yaml (optional) Dockerfile jobs.toml Used by the jcasc.py program. setup","title":"Image Git Repo Layout"},{"location":"mindset/","text":"Build Mindset Future changes to Jenkins Image construction should use the following mindset (the term Philosophy is a bit too fancy here). The lifecycle of building a Jenkins Image is as followed: Preimage Build The operations needed to gather all the resources for an image build should occur here. What this means for \u2018 Image Builds \u2019: We want to ensure that Dockerfiles are easy to follow, and can be maintained. Multistage builds are ok, but not for just running one command and gathering its results. Multistage builds should be used judiciously. What this means for \u2018 Container Runtime \u2019: There should be a narrow scope for what a container should do at runtime. Env vars evaluation for Jenkins is ok, but pulling a bunch of resources and performing plenty of groovy scripts with the job-dsl plugin is excessive and prone to error. e.g. docker-compose injects env vars into container runtime based on what you pass in as their values. JCasC plugin evaluates these env vars if they exist when looking in the \u2018 casc.yaml \u2019. Image Build The Dockerfiles should be simple and easy to follow. Simple activities like updating packages, chmoding files, and copying files over from the Docker context are encouraged. However, mangling the image file system is not. Container Runtime The modularity of a Jenkins Image shines here, as \u2018 casc.yaml \u2019 will heavily utilize env vars to be evaluated at runtime. This allows the same image to be run differently depending on the need(s).","title":"Build Mindset"},{"location":"mindset/#build-mindset","text":"Future changes to Jenkins Image construction should use the following mindset (the term Philosophy is a bit too fancy here). The lifecycle of building a Jenkins Image is as followed: Preimage Build The operations needed to gather all the resources for an image build should occur here. What this means for \u2018 Image Builds \u2019: We want to ensure that Dockerfiles are easy to follow, and can be maintained. Multistage builds are ok, but not for just running one command and gathering its results. Multistage builds should be used judiciously. What this means for \u2018 Container Runtime \u2019: There should be a narrow scope for what a container should do at runtime. Env vars evaluation for Jenkins is ok, but pulling a bunch of resources and performing plenty of groovy scripts with the job-dsl plugin is excessive and prone to error. e.g. docker-compose injects env vars into container runtime based on what you pass in as their values. JCasC plugin evaluates these env vars if they exist when looking in the \u2018 casc.yaml \u2019. Image Build The Dockerfiles should be simple and easy to follow. Simple activities like updating packages, chmoding files, and copying files over from the Docker context are encouraged. However, mangling the image file system is not. Container Runtime The modularity of a Jenkins Image shines here, as \u2018 casc.yaml \u2019 will heavily utilize env vars to be evaluated at runtime. This allows the same image to be run differently depending on the need(s).","title":"Build Mindset"},{"location":"processes/","text":"Tagging Commits In Image Git Repos Current versioning schema roughly looks like this: \u2018 vx.x.x \u2019, with x being some positive int. Should represent major.minor.patch , that being the intent. When tagging a point in the commit tree, the following process is in place (again, just at a best effort level). This should be followed in descending order, these are known as rules : If the Dockerfile changed as part of a new commit, then the image has changed and the tag should be incremented and assigned to the new commit. If some part of an image file system has changed (e.g. casc.yaml that should be in the $JENKINS_HOME ), then the most recent tag (e.g. if v1.0.0 and v1.0.1 exist, v1.0.1 would be the most recent tag) should be removed from its previous commit and reassigned to the new commit but not incremented. If the Dockerfile has not changed, and no part of an image\u2019s file system has changed, then no tagging needs to occur with the new commit. To follow this rule , if a base image changes, the child image does not need to increment/reassign its tag. EXTRA NOTE : Jenkins Images built for a particular version can be from any commit that follows rule (iii) up to any other commit that follows rule (i) / rule (ii) . Any commits existing between them are assumed to follow rule (iii) and can be used by that particular Jenkins Image version. Image file system changes > Dockerfile changes This needs to be brought up because looking at rule (ii) in the above procedure list, moving a particular tag to a new commit when its file system has changed means it will be harder to know when that image changed (aka, the tag incremented) when looking through the commit tree. Rational is that currently Dockerfiles have been skimmed down and the actual image should not change as often as its contents. Building Jenkins Images NOTE: TAGGING COMMITS SHOULD OCCUR FIRST AND BE SORTED OUT! OTHERWISE THERE IS NO GUARANTEE AN IMAGE WILL BE IN LINE WITH ITS IMAGE GIT REPO. To make the process of running a docker build easier, each Image Git Repo should provide a setup script that will prepare everything to construct a Jenkins Image . This script will more than likely utilize the jcasc.py program. This serves two fold: To provide a blueprint/trail for the \u2018 casc.yaml \u2019 used by the Jenkins service in the container. This is so we know how the casc.yaml was created. Though again, this isn\u2019t an image change but a Jenkins config change (meaning the file system will change with the new casc.yaml ). To have fewer keystrokes used...a programmer\u2019s goal ideally. docker build works here, though it should be mentioned the jcasc.py program does provide a docker-build command that provides some convenience with '--build-args' being already provided where possible. If using just docker build , currently I also append the follow options (this is for official builds anyways): --no-cache --build-arg BRANCH= You will have to assign the current branch the repo is in. --build-arg COMMIT= You will have to assign a commit that the image was built off of. --tag name:tag ( Docker format for tags) \u201c.\u201d (the context to send to the Docker Daemon )","title":"Processes"},{"location":"processes/#tagging-commits-in-image-git-repos","text":"Current versioning schema roughly looks like this: \u2018 vx.x.x \u2019, with x being some positive int. Should represent major.minor.patch , that being the intent. When tagging a point in the commit tree, the following process is in place (again, just at a best effort level). This should be followed in descending order, these are known as rules : If the Dockerfile changed as part of a new commit, then the image has changed and the tag should be incremented and assigned to the new commit. If some part of an image file system has changed (e.g. casc.yaml that should be in the $JENKINS_HOME ), then the most recent tag (e.g. if v1.0.0 and v1.0.1 exist, v1.0.1 would be the most recent tag) should be removed from its previous commit and reassigned to the new commit but not incremented. If the Dockerfile has not changed, and no part of an image\u2019s file system has changed, then no tagging needs to occur with the new commit. To follow this rule , if a base image changes, the child image does not need to increment/reassign its tag. EXTRA NOTE : Jenkins Images built for a particular version can be from any commit that follows rule (iii) up to any other commit that follows rule (i) / rule (ii) . Any commits existing between them are assumed to follow rule (iii) and can be used by that particular Jenkins Image version. Image file system changes > Dockerfile changes This needs to be brought up because looking at rule (ii) in the above procedure list, moving a particular tag to a new commit when its file system has changed means it will be harder to know when that image changed (aka, the tag incremented) when looking through the commit tree. Rational is that currently Dockerfiles have been skimmed down and the actual image should not change as often as its contents.","title":"Tagging Commits In Image Git Repos"},{"location":"processes/#building-jenkins-images","text":"NOTE: TAGGING COMMITS SHOULD OCCUR FIRST AND BE SORTED OUT! OTHERWISE THERE IS NO GUARANTEE AN IMAGE WILL BE IN LINE WITH ITS IMAGE GIT REPO. To make the process of running a docker build easier, each Image Git Repo should provide a setup script that will prepare everything to construct a Jenkins Image . This script will more than likely utilize the jcasc.py program. This serves two fold: To provide a blueprint/trail for the \u2018 casc.yaml \u2019 used by the Jenkins service in the container. This is so we know how the casc.yaml was created. Though again, this isn\u2019t an image change but a Jenkins config change (meaning the file system will change with the new casc.yaml ). To have fewer keystrokes used...a programmer\u2019s goal ideally. docker build works here, though it should be mentioned the jcasc.py program does provide a docker-build command that provides some convenience with '--build-args' being already provided where possible. If using just docker build , currently I also append the follow options (this is for official builds anyways): --no-cache --build-arg BRANCH= You will have to assign the current branch the repo is in. --build-arg COMMIT= You will have to assign a commit that the image was built off of. --tag name:tag ( Docker format for tags) \u201c.\u201d (the context to send to the Docker Daemon )","title":"Building Jenkins Images"}]}